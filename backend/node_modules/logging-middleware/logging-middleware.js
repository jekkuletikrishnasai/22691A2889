'use strict';
const bunyan = require('bunyan');

function createAddLog(ctx) {
    return function addLog(eventName, data, _isEmailNotification, _bypassEmail) {
        const isEmailNotification = _isEmailNotification || false;
        ctx._logs.push({
            eventName: eventName,
            data: data,
            isEmailNotification: isEmailNotification,
            bypassEmail: _bypassEmail
        });
    };
}

/** Clone the resp body and ingore some big object  */
function cloneRespBodyWithCriteria(respBody, ignore) {
    let result = {};
    if (respBody) {
        result = respBody;
        if (ignore && ignore.length > 0) {
            const jsonStr = JSON.stringify(respBody, function(key, value) {
                return ignore.indexOf(key) === -1 ? value : '##IGNORED:[' + typeof value + ']##';
            })
            result = JSON.parse(jsonStr);
        }
    }
    return result;
}

/***
 * Intercom Request Parser Service
 *
 * This service provides middleware which parses a given request, and reports to intercom.io some basic information.
 */
module.exports = function loggingMiddlewareClosure(appName, settings) {
    const IntercomService = require('intercom-service')(settings.intercom);
    const ignore = settings.log && settings.log.ignore;

    /** Create the logging utility, this will report to logentries.com using the token passed through the settings. */
    const logger = bunyan.createLogger({name: appName});

    return function *loggingMiddleware(next) {
        const ctx = this;

        /** Create an empty log object to be passed to the routes to populate */
        ctx._logs = [];
        ctx.log = createAddLog(ctx);

        /** Go handle the routes with the exposed ctx.log functionality */
        yield next;

        const user = ctx.authorizedUser;
        if(user) {
            /** Parse logs and create intercom events for each entry */
            ctx._logs.map(entry => IntercomService.createEvent(user.email || entry.bypassEmail
              , entry.eventName
              , { data: JSON.stringify(entry.data, null, 4) }
            ));

            /** Log Request Information */
            logger.info({
                response: {
                    status: ctx.status,
                    body: cloneRespBodyWithCriteria(ctx.body, ignore),
                    headers: ctx.response.header
                },
                request: {
                    body: ctx.request.body,
                    params: ctx.params,
                    query: ctx.query,
                    headers: ctx.headers
                },
                service: appName
            });

        }

        yield next;
    };
};
